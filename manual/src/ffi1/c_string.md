# C Strings

Let's add some C-style strings to the mix. C likes pointers to bytes in memory with a null (0) at the end. Rust likes to store a vector of utf-8 characters, and length separately (as does `std::string` in C++, with less UTF-8 help!).

Change up `mylib.h`:

```h
int double_it(int x);
void print_message(const char *message);
```

And add a body to `mylib.c`:

```c
#include "mylib.h"
#include <stdio.h>

// A really simple function that doubles a number
int double_it(int x) {
    return x * 2;
}

void print_message(const char *message) {
    printf("Printing a message from C: %s\n", message);
}
```

Now build it with `cargo build`, and `bindings.rs` has grown:

```rust
/* automatically generated by rust-bindgen 0.69.4 */

extern "C" {
    pub fn double_it(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_message(message: *const ::std::os::raw::c_char);
}
```

So how do we call the new function? Rust has a type called "c string":

```rust
mod mylib_c {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

fn main() {
    // The "c" prefix is a helper for making static C strings!
    let my_c_string = c"Hello World";

    unsafe {
        mylib_c::print_message(my_c_string.as_ptr());
    }

    // Or you can go from a regular string
    let my_string = "Hello String";
    let my_c_string = std::ffi::CString::new(my_string).unwrap();
    unsafe {
        mylib_c::print_message(my_c_string.as_ptr());
    }
}
```