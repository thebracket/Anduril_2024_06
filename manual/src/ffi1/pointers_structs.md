# Structures and Pointers

So we have primitives and strings. Let's work with a structure!

In your `mylib.h` add:

```h
struct MyStruct {
    int x;
    int y;
};

void print_struct(struct MyStruct s);

void print_ptr_to_struct(struct MyStruct *s);
```

And in your `mylib.c` add:

```c
void print_struct(struct MyStruct s) {
    printf("Printing a struct from C: %d, %d\n", s.x, s.y);
}

void print_ptr_to_struct(struct MyStruct *s) {
    printf("Printing a pointer to a struct from C: %d, %d\n", s->x, s->y);
}
```

Building it shows that `bindings.rs` has grown again:

```rust
/* automatically generated by rust-bindgen 0.69.4 */

extern "C" {
    pub fn double_it(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_message(message: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MyStruct {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MyStruct() {
    const UNINIT: ::std::mem::MaybeUninit<MyStruct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MyStruct>(),
        8usize,
        concat!("Size of: ", stringify!(MyStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<MyStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(MyStruct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MyStruct),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MyStruct),
            "::",
            stringify!(y)
        )
    );
}
extern "C" {
    pub fn print_struct(s: MyStruct);
}
extern "C" {
    pub fn print_ptr_to_struct(s: *mut MyStruct);
}

```

> Wait, bindgen made unit tests too? You can `cargo test` any complicated bindgen import to see that the bindings are at least present.

So let's adjust `main.rs` to try our new features:

```rust
mod mylib_c {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

fn main() {
    let mut data = mylib_c::MyStruct { x: 1, y: 2 };

    unsafe {
        mylib_c::print_struct(data);
        mylib_c::print_ptr_to_struct(&mut data as *mut mylib_c::MyStruct);
    }
}
```